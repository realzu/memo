# 실행 컨텍스트 (Execution Context)

## JS 엔진의 코드 실행 과정

> 소스코드의 "평가" -> "실행" 과정

1. 평가 과정
  - 실행 컨텍스트 생성
  - 선언문만 실행하여 *환경 레코드*에 식별자를 key로 등록
    - 환경 레코드(Environment Record): 식별자와 식별자에 바인딩된 값을 기록 => 🔔호이스팅
  - `{ x: undefined }`

2. 실행 과정
  - 선언문 이외의 코드 순차적으로 실행
  - 환경 레코드 참조 또는 업데이트(값 할당시)

- 코드 전체 순서
  - 전역 코드 평가(선언문만-변수/함수)
    - 콜 스택에 전역 실행컨텍스트 생성하며, 이 안에 있는 환경 레코드에 선언문 기록
      - var는 undefined로 기록
      - 전역 스코프에 등록
  - 전역 코드 실행
    - 평가 과정이 끝났으니 런타임 시작되어 순차적으로 코드 실행
    - 값 할당 또는 함수 호출
    - 함수 호출시, 전역코드의 실행을 일시중단하고 코드의 실행순서를 변경하여 해당 함수 내부로 진입
  - 함수 코드 평가
    - 매개변수 및 지역변수 선언문 실행 => 지역스코프에 등록
  - 함수 코드 실행
    - 런타임 시작
    - 식별자 없으면 스코프 체인을 통해 식별자 검색
    - 함수가 종료되면 실행컨텍스트는 사라짐

## 실행 컨텍스트

> 코드를 실행하는 데에 필요한 환경 제공 및 코드의 실행 순서를 관리하는 영역

`환경`: 코드 실행에 영향을 주는 조건이나 상태 (ex. 변수, 함수, 스코프, this..)  
so, 필요한 정보를 한 곳에 모아 제공하는 객체

LexicalEnvironment와 VariableEnvironment로 구성

- LexicalEnvironment
  - 실행 컨텍스트에서 환경 레코드(`Environment Record`) 및 외부 환경 참조(`Outer Environment Reference`) 영역을 가리킴

### 콜 스택

> 현재 실행되고있는 실행 컨텍스트를 추적하기 위한 구조

콜 스택 (Call Stack, 호출 스택)  
자바스크립트 엔진은 Memory Heap과 Call Stack의 구성요소로 이루어짐  

- 여기에 실행 컨텍스트가 쌓임
- 자바스크립트 엔진은 처음에 전역 코드 평가시 전역 실행컨텍스트부터 생성
- 이후 코드 실행하며 push(함수 호출) & pop(함수 종료)
- 가장 최상위에 있는 실행컨텍스트가 활성화되어있음

### 호이스팅

**환경 레코드**에 의한 호이스팅 현상
> 선언문이 마치 최상단에 끌어올려진 듯한 현상

- 변수 호이스팅
  - let, const
    - 실행컨텍스트 '평가' 과정에서 식별자를 기록하긴 하지만 값을 초기화하지는 않음 `{ y }`
    - 선언(o). 초기화(x). 선언과 동시에 값 할당 필요
    - 따라서, 선언 라인 이전에는 식별자 참조 불가
      - *일시적 사각지대 (Temporal Dead Zone)*
      - 선언 이전에 식별자를 참조할 수 없는 구역
  - var 키워드
    - 선언과 초기화 동시에 이루어져, 식별자에 암묵적으로 `undefined` 할당 (값 바인딩)
    - cf. 선언: 메모리 공간 확보 후 메모리 주소에 식별자 연결

- 함수 호이스팅
  - 함수 표현식
    - 변수 호이스팅과 동일하게 동작 (함수를 변수에 담고있어서)
    - 함수 선언 이전에 호출하면 에러
      - var: undefined로 초기화되는데 호출하니 Type error
      - let/const: 값이 초기화되지않아 참조하면 reference error
  - 함수 선언문
    - 선언과 동시에 함수 생성되어 환경 레코드에 기록
    - 이미 코드 실행시, 평가 단계에서 기록했기에 런타임 이후 선언 라인 전에도 호출 가능

```javascript
const foo = () => { }; // 함수 표현식
function bao() { }; // 함수 선언문
```

## 스코프

> 현재 접근할 수 있는 식별자들의 범위

by. 실행 컨텍스트의 Outer Environment Reference (외부 환경 참조)  
-> 바깥의 Lexical Environment 가리킴  
호출이 아닌, **정의**된 순간에 결정

- Outer Environment Reference
  - 함수 호출시 -> 실행컨텍스트 새로 생성
  - 이 때, 자바스크립트 엔진은 바깥 렉시컬 환경으로 돌아갈 수 있는 outer 만들어 둠 (like 사다리)
    - 이전 실행컨텍스트의 환경레코드 참조 -> 전역 실행 컨텍스트까지 도달 가능
  - So, 자바스크립트 엔진의 식별자 판단시 활용
    - 식별자를 찾을 때 현재 실행컨텍스트에 없으면 => outer(이전 실행컨텍스트)로 넘어가서 찾을 수 있음
      - => `스코프 체이닝`
    - 그리고 찾게 되면, 그 상위의 환경레코드에 있는 값까지는 도달할 필요가 없음
      - => `변수 섀도잉` 
  
- 변수 섀도잉 (Variable Shadowing. 변수 은닉화)
  - *동일한* 식별자로 인해, 상위 스코프에 선언된 식별자의 값이 가려지는 현상

```javascript
let water = false; // 변수 섀도잉

function goTo2F() {
  let water = true;
  function goTo3F() {
    console.log(water); // ? (-> true)
  }
  goTo3F();
}

goTo2F();
```

- 스코프 체인
  - 식별자를 결정할 때 활용하는 스코프들의 연결리스트
  - 현재 실행중인 실행 컨텍스트에서 식별자를 찾을 수 없으면, 이전 실행 컨텍스트로 이동해 검색
  - 3층에 없으면 2층 -> 없으면 1층으로 타고타고 환경레코드 참조 가능 => `스코프 체이닝`

: 실행 컨텍스트는 **식별자 결정**을 더욱 효율적으로 하기 위한 수단  

물론, 상위 실행컨텍스트로 스코프 체이닝하기 전에 Closure에 식별자가 있는지 먼저 판단 !!

## Closure (클로저)

> 자신이 생성될 때의 환경(Lexical Environment)을 기억하는 함수

이미 생명주기가 종료된 외부 함수의 변수를 참조하면서, 외부 함수보다 오래 생존하는 함수  
이러한 중첩 함수를 '클로저 (Closure)'라고 부른다.

함수가 함수를 반환할 때 (= 중첩 함수), 반환되는 함수는 **자신을 둘러싼 메모리 환경**을 가지고 함께 반환  
함수가 호출이 되어야만 접근 가능 -> 정보 은닉에 유용

```javascript
function outer() { // 외부함수
  var count = 0;
  function inner() { // 중첩함수
    count += 1;
  }
  return inner;
}

var newFn = outer(); // outer는 생명주기 종료 -> 콜스택에서 제거
newFn(); // 1 -- inner만 return됐지만 inner가 반환될 때 count 식별자를 가지고 나옴
newFn(); // 2 -- 그래서 outer 함수의 지역변수인 count를 참조하는 것
```


